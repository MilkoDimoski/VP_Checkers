CHECKERS Windows Forms Project by :	Milko Dimoski and Darko Dimitrov


 1. Опис на апликацијата 
Апликацијата што ја дизајниравме е класичен пример на Checkers игра. Развивме две опции за играње, 2 players style - каде може да играме против други наши колеги и One player style – каде сами можеме да играме против компјутерот 
2. Упатство за користење
 2.1 Нова игра
   
![image](https://github.com/MilkoDimoski/VP_Checkers/assets/127048801/6300f9c7-8a42-48cd-9777-00f3c8c2a986)

                                                (слика 1)

 При стартување на апликацијата (слика 1) потребно е да кликнеме на копчето Play за да започнеме нова игра. 
 
 ![image](https://github.com/MilkoDimoski/VP_Checkers/assets/127048801/d9f78679-1a37-4f0b-9ce3-b53e163fcaa9)
                                                
                                                (слика 2)

Откако ќе започнеме нова игра, се отвора прозорец (слика 2) каде што треба да избереме во кој мод сакаме да играме 1 player или 2 players. Следно треба да го избереме времето кое што сакаме да го има еден играч на располагање (5, 15 или 30 мин). Кога ќе ги избереме потребните полиња играта автоматски започнува.

 2.2 Правила на играње
 
 ![image](https://github.com/MilkoDimoski/VP_Checkers/assets/127048801/3f9295bf-44fb-454e-87d3-b54d24c0dd0f)
 
                                                (слика 3)

 Прв почнува секогаш црвениот играч. За мрдање на фигура потребно е да притиснеме на истата и автоматски ќе ни се изгенерираат полињата каде што можеме да се движиме (слика 3).

 ![image](https://github.com/MilkoDimoski/VP_Checkers/assets/127048801/9ee80014-dd84-44fa-a2dc-ca24c29bf062)
 
                                                (слика 4)

 Кога противничкиот играч ќе одигра на позиција каде што ќе можеме да му ја одземеме фигурата,според правилата кои ни ги наложува играта ние немаме опција да одиграме на друго поле (слика 4) .
Доколку на некој од играчите победи или пак на некого му истече времето, играта автоматски завршува.

 3. Претставување на проблемот

 • Главниот дел од кодот на задачата се наоѓа во public partial class Form1 
 
• Почетна Состојба Init() ;  Поставување на фигурите на почетните места со помош на матрица во методот

 • Прогласување на побеник Winner(List<Move>legalmovesplayer1,List<Move>legalmovesplayer2);  Се пресметува со помош на променливите legalmovesplayer1 и legalmovesplayer2 кои одредуваат колку слободни позиции има секој од играчите за движење на своите фигури. Според тоа се одредува во if условите дали играта е завршена со Draw или пак некој од играчите издвоил победа.
 
 • SwitchPlayer(); промена на тековниот играч на шаховската табла. Кога ќе се повика, играчот се менува од играч 1 на играч 2 и обратно. Исто така проверува дали играта е во режим на играч против компјутер и го активира алгоритмот за потег на компјутерот (AIMove()). 
 
• ApplyMove(int[,] board, Move move); Се користи копија од моменталната табла и се врши обновување на неа, односно се менуваат вредностите во согласност со потегот. Ако потегот вклучува одземање фигура,тогаш се отстранува зафатената фигура од таблата. Овој метод ја враќа обновената табла.

 • EvaluatePosition();Оваа метода се користи за да се оцени моменталната состојба на шаховската табла. Таа доделува бројки на состојбите на таблата, така што ја претставува нивната важност. Пресметува вкупниот број на фигури и кралеви за белите и црните играчи и доделува тежини на различни аспекти како контрола на центарот, контрола на крајот на таблата, и напредок на пешачките фигури кон крајот на противниковата табла.
 
 • UpdateUIAfterAIMove(Move move); Ги ажурира копчињата на таблата според потегот на компјутер, вклучувајќи зафатување на противнички фигури.
 
 • GenerateLegalMoves(int player); Генерира листа со легални потези за одреден играч на основа на состојбата на таблата и правилата на играта. 
 
• TryAddMovesInDirection(int fromRow, int fromCol, int rowIncrement, int colIncrement, List<Move> legalMoves); проверува и додава легални потези во одредена насока на таблата. Ги користи параметрите fromRow и fromCol како почетни координати, а rowIncrement и colIncrement го одредуваат правецот на движење. Потоа, методот додава потези во листата legalMoves и продолжува со движење сè додека останува во границите на таблата (IsInsideBorders). Доколку на патот се случи зафатување на противничка фигура, методот исто така вика TryAddJump за да го додаде тој потег како легален потег. 

• IsValidMove(int fromRow, int fromCol, int toRow, int toCol); Го проверува потегот дали е легален. Проверува дали потегот е во границите на таблата, дали дестинацијата е празна келија и дали потегот е дијагонален.

 • AiMove();   Се користи за потег на компјутерот. Го извршува алгоритмот Minimax за наоѓање на најдобриот потег за компјутерот на одредена длабочина. Потоа ја применува најдобрата одлука на таблата
 
 • GetPrevButtonColor(Button prevButton);  Ја добива претходната боја на копчето во зависност од неговата локација на таблата, за да се постави како позадинска боја.
 
 • StartTimer(); Го почнува тајмерот за играчите и го прикажува преостанатото време на екранот. • OnFigurePress(object sender, EventArgs e); Обработува клик на играч на фигура на таблата и ги прави потребните проверки и дејства врз основа на кликнатата фигура и тековниот статус на играта. • ShowPossibleSteps();Ги прикажува можностите за потези на тековниот играч, исклучувајќи ги непотребните. 

• SwitchButtonToCheat(Button button); Ја заменува обичната фигура со кралска фигура кога ќе стигне до крајот на таблата. 

• DeleteEaten(Button endButton, Button startButton); Ги брише заземените фигури од таблата кога играчот ќе одземе фигура. 

• ShowSteps(int iCurrFigure, int jCurrFigure, bool isOnestep = true); Ги прикажува сите можностите за потези на одредена фигура на таблата. 

• ShowDiagonal(int IcurrFigure, int JcurrFigure, bool isOneStep = false); Ги прикажува сите дијагонални потези за одредена фигура на таблата, со можност за долги потези доколку фигурата е крал.

 • DeterminePath(int ti, int tj); Ја одредува патеката на потегот и проверува дали е возможен.

 • CloseSimpleSteps(List<Button> simpleSteps); Ги затвора сите едноставни потези на таблата и ги оневозможува за клик
 
 • ShowProceduralEat(int i, int j, bool isOneStep = true); Ги прикажува зафатните потези за одредена фигура на таблата и ги оневозможува сите останати потези.
 
 • IsButtonHasEatStep(int IcurrFigure, int JcurrFigure, bool isOneStep, int[] dir);Проверува дали фигурата има можност да одзема противничка фигура 
 
• CloseSteps();Ги затвора сите прикажани потези на таблата. 

• IsInsideBorders(int ti, int tj); Проверува дали дадената локација се наоѓа во границите на играта. 

• ActivateAllButtons();Ги активира сите копчиња на таблата за да бидат достапни за кликнување.

 • DeactivateAllButtons();Ги оневозможува сите копчиња на таблата, исто така ги враќа на нивните претходни бои. 
 
• StartGame();Оваа метода се користи за почетокот на играта и за подесување на опциите што ги избрале играчите пред играта да започне. 

• Методот Minimax(int[,] board, int currentPlayer, int depth, int alpha, int beta, Form1 formInstance) во класата Move; Се користи за наоѓање на најдобар потег во стратегиската игра. Пресметувањето се прави рекурзивно. Основната идеја е да се симулираат сите можни потези и да се избере потегот кој ќе го максимизира или минимизира резултатот во зависност од играчот. Оценката за секој потег се чува во променливата bestScore, и ако се пронајде подобар потег, таа се ажурира. Алфа-бета се користи за да се избегнат непотребни пребарувања кога знаеме дека некои потези нема да донесат подобар резултат. На крајот, функцијата го враќа најдобриот потег што е пронајден во текот на пребарувањето.
